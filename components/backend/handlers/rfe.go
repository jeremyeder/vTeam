package handlers

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"ambient-code-backend/git"
	"ambient-code-backend/types"

	"github.com/gin-gonic/gin"
	"k8s.io/apimachinery/pkg/api/errors"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"
)

// Package-level variables for dependency injection (RFE-specific)
var (
	GetRFEWorkflowResource     func() schema.GroupVersionResource
	UpsertProjectRFEWorkflowCR func(dynamic.Interface, *types.RFEWorkflow) error
	PerformRepoSeeding         func(context.Context, *types.RFEWorkflow, string, string, string, string, string, string, string, string) (bool, error)
	CheckRepoSeeding           func(context.Context, string, *string, string) (bool, map[string]interface{}, error)
	CheckBranchExists          func(context.Context, string, string, string) (bool, error)
	RfeFromUnstructured        func(*unstructured.Unstructured) *types.RFEWorkflow
)

// Type aliases for RFE workflow types
type RFEWorkflow = types.RFEWorkflow
type CreateRFEWorkflowRequest = types.CreateRFEWorkflowRequest
type GitRepository = types.GitRepository
type WorkflowJiraLink = types.WorkflowJiraLink

// rfeLinkSessionRequest holds the request body for linking a session to an RFE workflow
type rfeLinkSessionRequest struct {
	ExistingName string `json:"existingName"`
	Phase        string `json:"phase"`
}

// normalizeRepoURL normalizes a repository URL for comparison
func normalizeRepoURL(repoURL string) string {
	normalized := strings.ToLower(strings.TrimSpace(repoURL))
	// Remove .git suffix
	normalized = strings.TrimSuffix(normalized, ".git")
	// Remove trailing slash
	normalized = strings.TrimSuffix(normalized, "/")
	return normalized
}

// validateUniqueRepositories checks that all repository URLs are unique
func validateUniqueRepositories(umbrellaRepo *GitRepository, supportingRepos []GitRepository) error {
	seen := make(map[string]bool)

	// Check umbrella repo
	if umbrellaRepo != nil && umbrellaRepo.URL != "" {
		normalized := normalizeRepoURL(umbrellaRepo.URL)
		seen[normalized] = true
	}

	// Check supporting repos
	for _, repo := range supportingRepos {
		if repo.URL == "" {
			continue
		}
		normalized := normalizeRepoURL(repo.URL)
		if seen[normalized] {
			return fmt.Errorf("duplicate repository URL detected: %s", repo.URL)
		}
		seen[normalized] = true
	}

	return nil
}

// ListProjectRFEWorkflows lists all RFE workflows for a project
func ListProjectRFEWorkflows(c *gin.Context) {
	project := c.Param("projectName")
	var workflows []RFEWorkflow
	// Prefer CRD list with request-scoped client; fallback to file scan if unavailable or fails
	gvr := GetRFEWorkflowResource()
	_, reqDyn := GetK8sClientsForRequest(c)
	if reqDyn != nil {
		if list, err := reqDyn.Resource(gvr).Namespace(project).List(c.Request.Context(), v1.ListOptions{LabelSelector: fmt.Sprintf("project=%s", project)}); err == nil {
			for _, item := range list.Items {
				wf := RfeFromUnstructured(&item)
				if wf == nil {
					continue
				}
				workflows = append(workflows, *wf)
			}
		}
	}
	if workflows == nil {
		workflows = []RFEWorkflow{}
	}
	// Return slim summaries: omit artifacts/agentSessions/phaseResults/status/currentPhase
	summaries := make([]map[string]interface{}, 0, len(workflows))
	for _, w := range workflows {
		item := map[string]interface{}{
			"id":            w.ID,
			"title":         w.Title,
			"description":   w.Description,
			"branchName":    w.BranchName,
			"project":       w.Project,
			"workspacePath": w.WorkspacePath,
			"createdAt":     w.CreatedAt,
			"updatedAt":     w.UpdatedAt,
		}
		if w.UmbrellaRepo != nil {
			u := map[string]interface{}{"url": w.UmbrellaRepo.URL}
			if w.UmbrellaRepo.Branch != nil {
				u["branch"] = *w.UmbrellaRepo.Branch
			}
			item["umbrellaRepo"] = u
		}
		if len(w.SupportingRepos) > 0 {
			repos := make([]map[string]interface{}, 0, len(w.SupportingRepos))
			for _, r := range w.SupportingRepos {
				rm := map[string]interface{}{"url": r.URL}
				if r.Branch != nil {
					rm["branch"] = *r.Branch
				}
				repos = append(repos, rm)
			}
			item["supportingRepos"] = repos
		}
		summaries = append(summaries, item)
	}
	c.JSON(http.StatusOK, gin.H{"workflows": summaries})
}

// CreateProjectRFEWorkflow creates a new RFE workflow for a project
func CreateProjectRFEWorkflow(c *gin.Context) {
	project := c.Param("projectName")
	var req CreateRFEWorkflowRequest
	bodyBytes, _ := c.GetRawData()
	c.Request.Body = io.NopCloser(strings.NewReader(string(bodyBytes)))
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed: " + err.Error()})
		return
	}
	now := time.Now().UTC().Format(time.RFC3339)
	workflowID := fmt.Sprintf("rfe-%d", time.Now().Unix())

	// Branch name is required and generated by frontend (auto-populated from title, user-editable)
	// Frontend generates: ambient-{first-three-words-from-title}
	// Backend only validates that it's not empty and not a protected branch
	branchName := strings.TrimSpace(req.BranchName)
	if err := git.ValidateBranchName(branchName); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate no duplicate repository URLs
	if err := validateUniqueRepositories(&req.UmbrellaRepo, req.SupportingRepos); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	workflow := &RFEWorkflow{
		ID:              workflowID,
		Title:           req.Title,
		Description:     req.Description,
		BranchName:      branchName,
		UmbrellaRepo:    &req.UmbrellaRepo,
		SupportingRepos: req.SupportingRepos,
		WorkspacePath:   req.WorkspacePath,
		Project:         project,
		CreatedAt:       now,
		UpdatedAt:       now,
	}
	_, reqDyn := GetK8sClientsForRequest(c)
	if err := UpsertProjectRFEWorkflowCR(reqDyn, workflow); err != nil {
		log.Printf("⚠️ Failed to upsert RFEWorkflow CR: %v", err)
	}

	// Seeding (spec-kit + agents) is now handled by POST /seed endpoint after creation

	c.JSON(http.StatusCreated, workflow)
}

// UpdateProjectRFEWorkflow updates an existing RFE workflow's repository configuration
// This is primarily used to fix repository URLs before seeding
func UpdateProjectRFEWorkflow(c *gin.Context) {
	project := c.Param("projectName")
	id := c.Param("id")

	var req types.UpdateRFEWorkflowRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Validation failed: " + err.Error()})
		return
	}

	// Get the workflow
	gvr := GetRFEWorkflowResource()
	_, reqDyn := GetK8sClientsForRequest(c)
	if reqDyn == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
		return
	}

	item, err := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), id, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
		} else if errors.IsForbidden(err) {
			c.JSON(http.StatusForbidden, gin.H{"error": "You don't have permission to access this workflow"})
		} else {
			log.Printf("Failed to get workflow %s: %v", id, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve workflow"})
		}
		return
	}

	wf := RfeFromUnstructured(item)
	if wf == nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid workflow"})
		return
	}

	// Validate no duplicate repository URLs if repositories are being updated
	if req.UmbrellaRepo != nil || req.SupportingRepos != nil {
		umbrellaRepo := req.UmbrellaRepo
		if umbrellaRepo == nil {
			umbrellaRepo = wf.UmbrellaRepo
		}
		supportingRepos := req.SupportingRepos
		if supportingRepos == nil {
			supportingRepos = wf.SupportingRepos
		}
		if err := validateUniqueRepositories(umbrellaRepo, supportingRepos); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}
	}

	// Update the CR
	obj := item.DeepCopy()
	spec, ok := obj.Object["spec"].(map[string]interface{})
	if !ok {
		spec = make(map[string]interface{})
		obj.Object["spec"] = spec
	}

	// Update fields if provided
	if req.Title != nil {
		spec["title"] = *req.Title
	}
	if req.Description != nil {
		spec["description"] = *req.Description
	}
	if req.UmbrellaRepo != nil {
		spec["umbrellaRepo"] = map[string]interface{}{
			"url":    req.UmbrellaRepo.URL,
			"branch": req.UmbrellaRepo.Branch,
		}
	}
	if req.SupportingRepos != nil {
		repos := make([]interface{}, len(req.SupportingRepos))
		for i, r := range req.SupportingRepos {
			repos[i] = map[string]interface{}{
				"url":    r.URL,
				"branch": r.Branch,
			}
		}
		spec["supportingRepos"] = repos
	}
	if req.ParentOutcome != nil {
		spec["parentOutcome"] = *req.ParentOutcome
	}

	// Update the CR
	updated, err := reqDyn.Resource(gvr).Namespace(project).Update(c.Request.Context(), obj, v1.UpdateOptions{})
	if err != nil {
		log.Printf("Failed to update RFEWorkflow CR: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update workflow"})
		return
	}

	// Convert back to RFEWorkflow type
	updatedWf := RfeFromUnstructured(updated)
	if updatedWf == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to parse updated workflow"})
		return
	}

	c.JSON(http.StatusOK, updatedWf)
}

// SeedProjectRFEWorkflow seeds the umbrella repo with spec-kit and agents via direct git operations
func SeedProjectRFEWorkflow(c *gin.Context) {
	project := c.Param("projectName")
	id := c.Param("id")

	// Get the workflow
	gvr := GetRFEWorkflowResource()
	reqK8s, reqDyn := GetK8sClientsForRequest(c)
	if reqDyn == nil || reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
		return
	}

	item, err := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), id, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
		} else if errors.IsForbidden(err) {
			c.JSON(http.StatusForbidden, gin.H{"error": "You don't have permission to access this workflow"})
		} else {
			log.Printf("Failed to get workflow %s: %v", id, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve workflow"})
		}
		return
	}
	wf := RfeFromUnstructured(item)
	if wf == nil || wf.UmbrellaRepo == nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "No spec repo configured"})
		return
	}

	// Ensure we have a branch name
	if wf.BranchName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Workflow missing branch name"})
		return
	}

	// Get user ID from forwarded identity middleware
	userID, _ := c.Get("userID")
	userIDStr, ok := userID.(string)
	if !ok || userIDStr == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User identity required"})
		return
	}

	githubToken, err := GetGitHubToken(c.Request.Context(), reqK8s, reqDyn, project, userIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Read request body for optional agent source and spec-kit settings
	type SeedRequest struct {
		AgentSourceURL    string `json:"agentSourceUrl,omitempty"`
		AgentSourceBranch string `json:"agentSourceBranch,omitempty"`
		AgentSourcePath   string `json:"agentSourcePath,omitempty"`
		SpecKitRepo       string `json:"specKitRepo,omitempty"`
		SpecKitVersion    string `json:"specKitVersion,omitempty"`
		SpecKitTemplate   string `json:"specKitTemplate,omitempty"`
	}
	var req SeedRequest
	_ = c.ShouldBindJSON(&req)

	// Defaults
	agentURL := req.AgentSourceURL
	if agentURL == "" {
		agentURL = "https://github.com/ambient-code/vTeam.git"
	}
	agentBranch := req.AgentSourceBranch
	if agentBranch == "" {
		agentBranch = "main"
	}
	agentPath := req.AgentSourcePath
	if agentPath == "" {
		agentPath = "agents"
	}
	// Spec-kit configuration: request body > environment variables > hardcoded defaults
	specKitRepo := req.SpecKitRepo
	if specKitRepo == "" {
		if envRepo := strings.TrimSpace(os.Getenv("SPEC_KIT_REPO")); envRepo != "" {
			specKitRepo = envRepo
		} else {
			specKitRepo = "github/spec-kit"
		}
	}
	specKitVersion := req.SpecKitVersion
	if specKitVersion == "" {
		if envVersion := strings.TrimSpace(os.Getenv("SPEC_KIT_VERSION")); envVersion != "" {
			specKitVersion = envVersion
		} else {
			specKitVersion = "main"
		}
	}
	specKitTemplate := req.SpecKitTemplate
	if specKitTemplate == "" {
		if envTemplate := strings.TrimSpace(os.Getenv("SPEC_KIT_TEMPLATE")); envTemplate != "" {
			specKitTemplate = envTemplate
		} else {
			specKitTemplate = "spec-kit-template-claude-sh"
		}
	}

	// Perform seeding operations with platform-managed branch
	branchExisted, seedErr := PerformRepoSeeding(c.Request.Context(), wf, wf.BranchName, githubToken, agentURL, agentBranch, agentPath, specKitRepo, specKitVersion, specKitTemplate)

	if seedErr != nil {
		log.Printf("Failed to seed RFE workflow %s in project %s: %v", id, project, seedErr)
		c.JSON(http.StatusInternalServerError, gin.H{"error": seedErr.Error()})
		return
	}

	message := "Repository seeded successfully"
	if branchExisted {
		message = fmt.Sprintf("Repository seeded successfully. Note: Branch '%s' already existed and will be modified by this RFE.", wf.BranchName)
	}

	c.JSON(http.StatusOK, gin.H{
		"status":        "completed",
		"message":       message,
		"branchName":    wf.BranchName,
		"branchExisted": branchExisted,
	})
}

// CheckProjectRFEWorkflowSeeding checks if the umbrella repo is seeded by querying GitHub API
func CheckProjectRFEWorkflowSeeding(c *gin.Context) {
	project := c.Param("projectName")
	id := c.Param("id")

	// Get the workflow
	gvr := GetRFEWorkflowResource()
	reqK8s, reqDyn := GetK8sClientsForRequest(c)
	if reqDyn == nil || reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
		return
	}

	item, err := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), id, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
		} else if errors.IsForbidden(err) {
			c.JSON(http.StatusForbidden, gin.H{"error": "You don't have permission to access this workflow"})
		} else {
			log.Printf("Failed to get workflow %s: %v", id, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve workflow"})
		}
		return
	}
	wf := RfeFromUnstructured(item)
	if wf == nil || wf.UmbrellaRepo == nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "No spec repo configured"})
		return
	}

	// Get user ID from forwarded identity middleware
	userID, _ := c.Get("userID")
	userIDStr, ok := userID.(string)
	if !ok || userIDStr == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User identity required"})
		return
	}

	githubToken, err := GetGitHubToken(c.Request.Context(), reqK8s, reqDyn, project, userIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if umbrella repo is seeded - use the generated feature branch, not the base branch
	branchToCheck := wf.UmbrellaRepo.Branch
	if wf.BranchName != "" {
		branchToCheck = &wf.BranchName
	}
	umbrellaSeeded, umbrellaDetails, err := CheckRepoSeeding(c.Request.Context(), wf.UmbrellaRepo.URL, branchToCheck, githubToken)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Check if all supporting repos have the feature branch
	supportingReposStatus := []map[string]interface{}{}
	allSupportingReposSeeded := true

	for _, supportingRepo := range wf.SupportingRepos {
		branchExists, err := CheckBranchExists(c.Request.Context(), supportingRepo.URL, wf.BranchName, githubToken)
		if err != nil {
			log.Printf("Warning: failed to check branch in supporting repo %s: %v", supportingRepo.URL, err)
			allSupportingReposSeeded = false
			supportingReposStatus = append(supportingReposStatus, map[string]interface{}{
				"repoURL":      supportingRepo.URL,
				"branchExists": false,
				"error":        err.Error(),
			})
			continue
		}

		if !branchExists {
			allSupportingReposSeeded = false
		}

		supportingReposStatus = append(supportingReposStatus, map[string]interface{}{
			"repoURL":      supportingRepo.URL,
			"branchExists": branchExists,
		})
	}

	// Overall seeding is complete only if umbrella repo is seeded AND all supporting repos have the branch
	isFullySeeded := umbrellaSeeded && allSupportingReposSeeded

	c.JSON(http.StatusOK, gin.H{
		"isSeeded": isFullySeeded,
		"specRepo": gin.H{
			"isSeeded": umbrellaSeeded,
			"details":  umbrellaDetails,
		},
		"supportingRepos": supportingReposStatus,
	})
}

// GetProjectRFEWorkflow retrieves a specific RFE workflow by ID
func GetProjectRFEWorkflow(c *gin.Context) {
	project := c.Param("projectName")
	id := c.Param("id")
	// Try CRD with request-scoped client first
	gvr := GetRFEWorkflowResource()
	_, reqDyn := GetK8sClientsForRequest(c)
	var wf *RFEWorkflow
	var err error
	if reqDyn != nil {
		if item, gerr := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), id, v1.GetOptions{}); gerr == nil {
			wf = RfeFromUnstructured(item)
			err = nil
		} else {
			err = gerr
		}
	}
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
		return
	}
	// Return slim object without artifacts/agentSessions/phaseResults/status/currentPhase
	resp := map[string]interface{}{
		"id":            wf.ID,
		"title":         wf.Title,
		"description":   wf.Description,
		"branchName":    wf.BranchName,
		"project":       wf.Project,
		"workspacePath": wf.WorkspacePath,
		"createdAt":     wf.CreatedAt,
		"updatedAt":     wf.UpdatedAt,
	}
	if wf.ParentOutcome != nil {
		resp["parentOutcome"] = *wf.ParentOutcome
	}
	if len(wf.JiraLinks) > 0 {
		links := make([]map[string]interface{}, 0, len(wf.JiraLinks))
		for _, l := range wf.JiraLinks {
			links = append(links, map[string]interface{}{"path": l.Path, "jiraKey": l.JiraKey})
		}
		resp["jiraLinks"] = links
	}
	if wf.UmbrellaRepo != nil {
		u := map[string]interface{}{"url": wf.UmbrellaRepo.URL}
		if wf.UmbrellaRepo.Branch != nil {
			u["branch"] = *wf.UmbrellaRepo.Branch
		}
		resp["umbrellaRepo"] = u
	}
	if len(wf.SupportingRepos) > 0 {
		repos := make([]map[string]interface{}, 0, len(wf.SupportingRepos))
		for _, r := range wf.SupportingRepos {
			rm := map[string]interface{}{"url": r.URL}
			if r.Branch != nil {
				rm["branch"] = *r.Branch
			}
			repos = append(repos, rm)
		}
		resp["supportingRepos"] = repos
	}
	c.JSON(http.StatusOK, resp)
}

// GetProjectRFEWorkflowSummary computes derived phase/status and progress based on workspace files and linked sessions
// GET /api/projects/:projectName/rfe-workflows/:id/summary
func GetProjectRFEWorkflowSummary(c *gin.Context) {
	project := c.Param("projectName")
	id := c.Param("id")

	// Determine workspace and expected files
	// workspace content removed
	specsItems := []contentListItem{}

	hasSpec := false
	hasPlan := false
	hasTasks := false

	// helper to scan a list for target filenames
	scanFor := func(items []contentListItem) (bool, bool, bool) {
		s, p, t := false, false, false
		for _, it := range items {
			if it.IsDir {
				continue
			}
			switch strings.ToLower(it.Name) {
			case "spec.md":
				s = true
			case "plan.md":
				p = true
			case "tasks.md":
				t = true
			}
		}
		return s, p, t
	}

	// First check directly under specs/
	if len(specsItems) > 0 {
		s, p, t := scanFor(specsItems)
		hasSpec, hasPlan, hasTasks = s, p, t
		// If not found, check first subfolder under specs/
		if !hasSpec && !hasPlan && !hasTasks {
			for _, it := range specsItems {
				if it.IsDir {
					subItems := []contentListItem{}
					s2, p2, t2 := scanFor(subItems)
					hasSpec, hasPlan, hasTasks = s2, p2, t2
					break
				}
			}
		}
	}

	// Sessions: find linked sessions and compute running/failed flags
	gvr := GetAgenticSessionV1Alpha1Resource()
	_, reqDyn := GetK8sClientsForRequest(c)
	anyRunning := false
	anyFailed := false
	if reqDyn != nil {
		selector := fmt.Sprintf("rfe-workflow=%s,project=%s", id, project)
		if list, err := reqDyn.Resource(gvr).Namespace(project).List(c.Request.Context(), v1.ListOptions{LabelSelector: selector}); err == nil {
			for _, item := range list.Items {
				status, _ := item.Object["status"].(map[string]interface{})
				phaseStr := strings.ToLower(fmt.Sprintf("%v", status["phase"]))
				if phaseStr == "running" || phaseStr == "creating" || phaseStr == "pending" {
					anyRunning = true
				}
				if phaseStr == "failed" || phaseStr == "error" {
					anyFailed = true
				}
			}
		}
	}

	// Derive phase and status
	var phase string
	switch {
	case !hasSpec && !hasPlan && !hasTasks:
		phase = "pre"
	case !hasSpec:
		phase = "specify"
	case !hasPlan:
		phase = "plan"
	case !hasTasks:
		phase = "tasks"
	default:
		phase = "completed"
	}

	status := "not started"
	if anyRunning {
		status = "running"
	} else if hasSpec || hasPlan || hasTasks {
		status = "in progress"
	}
	if hasSpec && hasPlan && hasTasks && !anyRunning {
		status = "completed"
	}
	if anyFailed && status != "running" {
		status = "attention"
	}

	progress := float64(0)
	done := 0
	if hasSpec {
		done++
	}
	if hasPlan {
		done++
	}
	if hasTasks {
		done++
	}
	progress = float64(done) / 3.0 * 100.0

	c.JSON(http.StatusOK, gin.H{
		"phase":    phase,
		"status":   status,
		"progress": progress,
		"files": gin.H{
			"spec":  hasSpec,
			"plan":  hasPlan,
			"tasks": hasTasks,
		},
	})
}

// DeleteProjectRFEWorkflow deletes an RFE workflow
func DeleteProjectRFEWorkflow(c *gin.Context) {
	id := c.Param("id")
	// Delete CR
	gvr := GetRFEWorkflowResource()
	_, reqDyn := GetK8sClientsForRequest(c)
	if reqDyn != nil {
		_ = reqDyn.Resource(gvr).Namespace(c.Param("projectName")).Delete(c.Request.Context(), id, v1.DeleteOptions{})
	}
	c.JSON(http.StatusOK, gin.H{"message": "Workflow deleted successfully"})
}

// ListProjectRFEWorkflowSessions lists sessions linked to a project-scoped RFE workflow by label selector
func ListProjectRFEWorkflowSessions(c *gin.Context) {
	project := c.Param("projectName")
	id := c.Param("id")
	gvr := GetAgenticSessionV1Alpha1Resource()
	selector := fmt.Sprintf("rfe-workflow=%s,project=%s", id, project)
	_, reqDyn := GetK8sClientsForRequest(c)
	if reqDyn == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing or invalid user token"})
		return
	}
	list, err := reqDyn.Resource(gvr).Namespace(project).List(c.Request.Context(), v1.ListOptions{LabelSelector: selector})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list sessions", "details": err.Error()})
		return
	}

	// Return full session objects for UI
	sessions := make([]map[string]interface{}, 0, len(list.Items))
	for _, item := range list.Items {
		sessions = append(sessions, item.Object)
	}
	c.JSON(http.StatusOK, gin.H{"sessions": sessions})
}

// AddProjectRFEWorkflowSession adds/links an existing session to an RFE by applying labels
func AddProjectRFEWorkflowSession(c *gin.Context) {
	project := c.Param("projectName")
	id := c.Param("id")
	var req rfeLinkSessionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
		return
	}
	if req.ExistingName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "existingName is required for linking in this version"})
		return
	}
	gvr := GetAgenticSessionV1Alpha1Resource()
	_, reqDyn := GetK8sClientsForRequest(c)
	if reqDyn == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing or invalid user token"})
		return
	}
	obj, err := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), req.ExistingName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch session", "details": err.Error()})
		return
	}
	meta, _ := obj.Object["metadata"].(map[string]interface{})
	labels, _ := meta["labels"].(map[string]interface{})
	if labels == nil {
		labels = map[string]interface{}{}
		meta["labels"] = labels
	}
	labels["project"] = project
	labels["rfe-workflow"] = id
	if req.Phase != "" {
		labels["rfe-phase"] = req.Phase
	}
	// Update the resource
	updated, err := reqDyn.Resource(gvr).Namespace(project).Update(c.Request.Context(), obj, v1.UpdateOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update session labels", "details": err.Error()})
		return
	}
	_ = updated
	c.JSON(http.StatusOK, gin.H{"message": "Session linked to RFE", "session": req.ExistingName})
}

// RemoveProjectRFEWorkflowSession removes/unlinks a session from an RFE by clearing linkage labels (non-destructive)
func RemoveProjectRFEWorkflowSession(c *gin.Context) {
	project := c.Param("projectName")
	_ = project // currently unused but kept for parity/logging if needed
	id := c.Param("id")
	sessionName := c.Param("sessionName")
	gvr := GetAgenticSessionV1Alpha1Resource()
	_, reqDyn := GetK8sClientsForRequest(c)
	if reqDyn == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing or invalid user token"})
		return
	}
	obj, err := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch session", "details": err.Error()})
		return
	}
	meta, _ := obj.Object["metadata"].(map[string]interface{})
	labels, _ := meta["labels"].(map[string]interface{})
	if labels != nil {
		delete(labels, "rfe-workflow")
		delete(labels, "rfe-phase")
	}
	if _, err := reqDyn.Resource(gvr).Namespace(project).Update(c.Request.Context(), obj, v1.UpdateOptions{}); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update session labels", "details": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"message": "Session unlinked from RFE", "session": sessionName, "rfe": id})
}

// GetProjectRFEWorkflowAgents fetches agent definitions from the workflow's umbrella repository
// GET /api/projects/:projectName/rfe-workflows/:id/agents
func GetProjectRFEWorkflowAgents(c *gin.Context) {
	project := c.Param("projectName")
	id := c.Param("id")

	// Get the workflow
	gvr := GetRFEWorkflowResource()
	reqK8s, reqDyn := GetK8sClientsForRequest(c)
	if reqDyn == nil || reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
		return
	}

	item, err := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), id, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
		} else if errors.IsForbidden(err) {
			c.JSON(http.StatusForbidden, gin.H{"error": "You don't have permission to access this workflow"})
		} else {
			log.Printf("Failed to get workflow %s: %v", id, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve workflow"})
		}
		return
	}
	wf := RfeFromUnstructured(item)
	if wf == nil || wf.UmbrellaRepo == nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "No spec repo configured"})
		return
	}

	// Get user ID from forwarded identity middleware
	userID, _ := c.Get("userID")
	userIDStr, ok := userID.(string)
	if !ok || userIDStr == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User identity required"})
		return
	}

	githubToken, err := GetGitHubToken(c.Request.Context(), reqK8s, reqDyn, project, userIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Parse repo owner/name from umbrella repo URL
	repoURL := wf.UmbrellaRepo.URL
	owner, repoName, err := parseOwnerRepoFromURL(repoURL)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Invalid repository URL: %v", err)})
		return
	}

	// Get ref (branch) - use the generated feature branch, not the base branch
	ref := "main"
	if wf.BranchName != "" {
		ref = wf.BranchName
	} else if wf.UmbrellaRepo.Branch != nil {
		ref = *wf.UmbrellaRepo.Branch
	}

	// Fetch agents from .claude/agents directory
	agents, err := fetchAgentsFromRepo(c.Request.Context(), owner, repoName, ref, githubToken)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"agents": agents})
}

// parseOwnerRepoFromURL extracts owner and repo name from a GitHub URL
func parseOwnerRepoFromURL(repoURL string) (string, string, error) {
	// Remove .git suffix
	repoURL = strings.TrimSuffix(repoURL, ".git")

	// Handle https://github.com/owner/repo
	if strings.HasPrefix(repoURL, "http://") || strings.HasPrefix(repoURL, "https://") {
		parts := strings.Split(strings.TrimPrefix(strings.TrimPrefix(repoURL, "https://"), "http://"), "/")
		if len(parts) >= 3 {
			return parts[1], parts[2], nil
		}
	}

	// Handle git@github.com:owner/repo
	if strings.Contains(repoURL, "@") {
		parts := strings.Split(repoURL, ":")
		if len(parts) == 2 {
			repoParts := strings.Split(parts[1], "/")
			if len(repoParts) == 2 {
				return repoParts[0], repoParts[1], nil
			}
		}
	}

	// Handle owner/repo format
	parts := strings.Split(repoURL, "/")
	if len(parts) == 2 {
		return parts[0], parts[1], nil
	}

	return "", "", fmt.Errorf("unable to parse repository URL")
}

// Agent represents an agent definition from .claude/agents directory
type Agent struct {
	Persona     string `json:"persona"`
	Name        string `json:"name"`
	Role        string `json:"role"`
	Description string `json:"description"`
}

// fetchAgentsFromRepo fetches and parses agent definitions from .claude/agents directory
func fetchAgentsFromRepo(ctx context.Context, owner, repo, ref, token string) ([]Agent, error) {
	api := "https://api.github.com"
	agentsPath := ".claude/agents"

	// Fetch directory listing
	treeURL := fmt.Sprintf("%s/repos/%s/%s/contents/%s?ref=%s", api, owner, repo, agentsPath, ref)
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, treeURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Accept", "application/vnd.github+json")
	req.Header.Set("X-GitHub-Api-Version", "2022-11-28")

	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("GitHub request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotFound {
		// No .claude/agents directory - return empty array
		return []Agent{}, nil
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("GitHub API error %d: %s", resp.StatusCode, string(body))
	}

	var treeEntries []map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&treeEntries); err != nil {
		return nil, fmt.Errorf("failed to parse GitHub response: %w", err)
	}

	// Filter for .md files
	var agentFiles []string
	for _, entry := range treeEntries {
		name, _ := entry["name"].(string)
		typ, _ := entry["type"].(string)
		if typ == "file" && strings.HasSuffix(name, ".md") {
			agentFiles = append(agentFiles, name)
		}
	}

	// Fetch and parse each agent file
	agents := make([]Agent, 0, len(agentFiles))
	for _, filename := range agentFiles {
		agent, err := fetchAndParseAgentFile(ctx, api, owner, repo, ref, filename, token)
		if err != nil {
			log.Printf("Warning: failed to parse agent file %s: %v", filename, err)
			continue
		}
		agents = append(agents, agent)
	}

	return agents, nil
}

// fetchAndParseAgentFile fetches a single agent file and parses its metadata
func fetchAndParseAgentFile(ctx context.Context, api, owner, repo, ref, filename, token string) (Agent, error) {
	agentPath := fmt.Sprintf(".claude/agents/%s", filename)
	url := fmt.Sprintf("%s/repos/%s/%s/contents/%s?ref=%s", api, owner, repo, agentPath, ref)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return Agent{}, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Accept", "application/vnd.github+json")
	req.Header.Set("X-GitHub-Api-Version", "2022-11-28")

	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return Agent{}, fmt.Errorf("GitHub request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return Agent{}, fmt.Errorf("GitHub returned status %d", resp.StatusCode)
	}

	var fileData map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&fileData); err != nil {
		return Agent{}, fmt.Errorf("failed to parse GitHub response: %w", err)
	}

	// Decode base64 content
	content, _ := fileData["content"].(string)
	encoding, _ := fileData["encoding"].(string)

	var decodedContent string
	if strings.ToLower(encoding) == "base64" {
		raw := strings.ReplaceAll(content, "\n", "")
		data, err := base64.StdEncoding.DecodeString(raw)
		if err != nil {
			return Agent{}, fmt.Errorf("failed to decode base64 content: %w", err)
		}
		decodedContent = string(data)
	} else {
		decodedContent = content
	}

	// Parse persona from filename
	persona := strings.TrimSuffix(filename, ".md")

	// Generate default name from filename
	nameParts := strings.FieldsFunc(persona, func(r rune) bool {
		return r == '-' || r == '_'
	})
	for i, part := range nameParts {
		if len(part) > 0 {
			nameParts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	name := strings.Join(nameParts, " ")

	role := ""
	description := ""

	// Try to extract metadata from YAML frontmatter
	// Simple regex-based parsing (consider using a YAML library for production)
	lines := strings.Split(decodedContent, "\n")
	inFrontmatter := false
	for i, line := range lines {
		if i == 0 && strings.TrimSpace(line) == "---" {
			inFrontmatter = true
			continue
		}
		if inFrontmatter && strings.TrimSpace(line) == "---" {
			break
		}
		if inFrontmatter {
			if strings.HasPrefix(line, "name:") {
				name = strings.TrimSpace(strings.TrimPrefix(line, "name:"))
			} else if strings.HasPrefix(line, "role:") {
				role = strings.TrimSpace(strings.TrimPrefix(line, "role:"))
			} else if strings.HasPrefix(line, "description:") {
				description = strings.TrimSpace(strings.TrimPrefix(line, "description:"))
			}
		}
	}

	// If no description found, use first non-empty line after frontmatter
	if description == "" {
		afterFrontmatter := false
		for _, line := range lines {
			if afterFrontmatter {
				trimmed := strings.TrimSpace(line)
				if trimmed != "" && !strings.HasPrefix(trimmed, "#") {
					description = trimmed
					if len(description) > 150 {
						description = description[:150]
					}
					break
				}
			}
			if strings.TrimSpace(line) == "---" {
				if afterFrontmatter {
					break
				}
				afterFrontmatter = true
			}
		}
	}

	if description == "" {
		description = "No description available"
	}

	return Agent{
		Persona:     persona,
		Name:        name,
		Role:        role,
		Description: description,
	}, nil
}

// GetWorkflowJira proxies Jira issue fetch for a linked path
// GET /api/projects/:projectName/rfe-workflows/:id/jira?path=...
func GetWorkflowJira(c *gin.Context) {
	project := c.Param("projectName")
	id := c.Param("id")
	reqPath := strings.TrimSpace(c.Query("path"))
	if reqPath == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "path is required"})
		return
	}
	_, reqDyn := GetK8sClientsForRequest(c)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqDyn == nil || reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing or invalid user token"})
		return
	}
	// Load workflow to find key
	gvrWf := GetRFEWorkflowResource()
	item, err := reqDyn.Resource(gvrWf).Namespace(project).Get(c.Request.Context(), id, v1.GetOptions{})
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
		return
	}
	wf := RfeFromUnstructured(item)
	var key string
	for _, jl := range wf.JiraLinks {
		if strings.TrimSpace(jl.Path) == reqPath {
			key = jl.JiraKey
			break
		}
	}
	if key == "" {
		c.JSON(http.StatusNotFound, gin.H{"error": "No Jira linked for path"})
		return
	}
	// Load Jira creds
	// Determine secret name
	secretName := "ambient-runner-secrets"
	if obj, err := reqDyn.Resource(GetProjectSettingsResource()).Namespace(project).Get(c.Request.Context(), "projectsettings", v1.GetOptions{}); err == nil {
		if spec, ok := obj.Object["spec"].(map[string]interface{}); ok {
			if v, ok := spec["runnerSecretsName"].(string); ok && strings.TrimSpace(v) != "" {
				secretName = strings.TrimSpace(v)
			}
		}
	}
	sec, err := reqK8s.CoreV1().Secrets(project).Get(c.Request.Context(), secretName, v1.GetOptions{})
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to read runner secret", "details": err.Error()})
		return
	}
	get := func(k string) string {
		if b, ok := sec.Data[k]; ok {
			return string(b)
		}
		return ""
	}
	jiraURL := strings.TrimSpace(get("JIRA_URL"))
	jiraToken := strings.TrimSpace(get("JIRA_API_TOKEN"))
	if jiraURL == "" || jiraToken == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing Jira configuration in runner secret (JIRA_URL, JIRA_API_TOKEN required)"})
		return
	}
	// Determine auth header (Cloud vs Server/Data Center)
	authHeader := ""
	if strings.Contains(jiraURL, "atlassian.net") {
		// Jira Cloud - assume token is email:api_token format
		encoded := base64.StdEncoding.EncodeToString([]byte(jiraToken))
		authHeader = "Basic " + encoded
	} else {
		// Jira Server/Data Center
		authHeader = "Bearer " + jiraToken
	}

	jiraBase := strings.TrimRight(jiraURL, "/")
	endpoint := fmt.Sprintf("%s/rest/api/2/issue/%s", jiraBase, url.PathEscape(key))
	httpReq, _ := http.NewRequest("GET", endpoint, nil)
	httpReq.Header.Set("Authorization", authHeader)
	httpClient := &http.Client{Timeout: 30 * time.Second}
	httpResp, httpErr := httpClient.Do(httpReq)
	if httpErr != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": "Jira request failed", "details": httpErr.Error()})
		return
	}
	defer httpResp.Body.Close()
	respBody, _ := io.ReadAll(httpResp.Body)
	c.Data(httpResp.StatusCode, "application/json", respBody)
}
